module Task3_3 where

newtype PSet a = PSet{ contains :: (a -> Bool) }

-- Реализуйте классы Monoid и Functor
-- Объясните в комментариях, почему они реализованы именно так


-- пересечение
-- нейтральный - универсальное мн.
newtype PSetX a = PSetX{ containsX :: (a -> Bool) }
instance Semigroup (PSetX a) where 
    (<>) x y = mappend x y
instance Monoid (PSetX a) where
    -- пересечение с нейтральным - то же множество
    mempty = PSetX (\ _ -> True)
    -- комбинация пересечений - новое персечение, при котором 
    -- для каждого эллемента функция принадлежности каждому из первоначальных множеств дает истину, в виде ответа
    mappend (PSetX a) (PSetX b) = PSetX (\x -> (a x) && (b x))


-- объединение
-- нейтральный - пустое мн.
newtype PSetY a = PSetY{ containsY :: (a -> Bool) }
instance Semigroup (PSetY a) where 
    (<>) x y = mappend x y
instance Monoid (PSetY a) where
    -- объединение с нейтральным - то же множество
    mempty = PSetY (\ _ -> False)
    -- комбинация объединений - новое объединение, при котором элемент принадлежит хотя бы одному из них
    mappend (PSetY a) (PSetY b) = PSetY (\x -> (a x) || (b x))


-- разность
-- несеммитрична, а значит - не реализуема memty
newtype PSetMY a = PSetMY{ containsMY :: (a -> Bool) }


-- исключающая разность (носит название - симметричной в Т.М.)
-- нейтральный - пустое мн.
newtype PSetXO a = PSetXO{ containsXO :: (a -> Bool) }
instance Semigroup (PSetXO a) where 
    (<>) x y = mappend x y
instance Monoid (PSetXO a) where
    -- xor с нейтральным, суть есть - то же самое множество
    mempty = PSetXO (\ _ -> False)
    -- комбинация - элемент принадлежит только одному из множеств
    mappend (PSetXO a) (PSetXO b) = PSetXO (\x -> ((a x) && (not(b x))) || ((not(a x)) && (b x)))



-- непонятно как реализовать функтор, к множеству заданному лишь условие принадлежности эллемента, 
-- вообще говоря - должно быть так : создаем множество всех эллементов типа "а" (универсальное множество), 
-- далее - берем его пересечение с нашим множеством (к которому применяем функцию-аргумент), 
-- и применяем  ф-аргумент к каждому эллементу этого множества (пересечения U с Множеством-Аргументом).
-- (теперь можно сформировать глухой шаблон, для данного множества, который будет как бы по-элементарной проверкой на принадлежность)
-- - profit ???
